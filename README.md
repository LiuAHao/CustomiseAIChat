### **项目一：基于Reactor模式的高性能网络服务器**
**技术栈亮点**：多线程、网络编程、异步IO、协议解析、性能优化  
**参考开源项目**：Muduo、Nginx  
**核心功能实现**：  
1. **事件驱动架构**：使用`epoll/kqueue`实现非阻塞IO，参考Muduo的EventLoop设计  
2. **线程池管理**：通过`std::thread`与任务队列实现线程池，支持动态调整线程数量  
3. **HTTP协议解析**：实现HTTP/1.1请求解析，支持长连接与静态文件服务  
4. **性能压测**：集成WebBench进行QPS测试，优化锁竞争（如无锁队列）  

**实践步骤**：  
1. 使用C++11/17编写基础框架，定义Channel、EventLoop类管理事件  
2. 实现基于RAII的资源管理（如智能指针管理Socket连接）  
3. 集成第三方库（如cJSON处理HTTP请求体）  
4. 通过Valgrind检测内存泄漏，使用Perf优化热点代码  


I/O多路复用： 是非阻塞IO的一种特例，也是目前最经典、最常用的高性能IO模型。其具体处理方式是：先查询 IO 事件是否准备就绪，当 IO 事件准备就绪了，则会真正的通过系统调用实现数据读写；
查询操作，不管是否数据准备就绪都会立即返回，即非阻塞；因此，通常情况下，会通过轮训来不断监听 IO 事件是否准备就绪；因为操作是非阻塞的，这个过程中通常只需及少量线程（一般一个线程即可）来处理这个轮训操作，极大的解决阻塞模式下 IO 枯竭问题。
这种一个线程就可以监听所有网络连接的 IO 事件是否准备就绪的模式。

事件驱动：
将一个正常的请求分成多段来看待，每一段都可以分别进行优化（看场景需要）。
经典的一种切分方法是将「连接」和「业务线程」分开处理，当「连接层」有事件触发时提交给「业务线程」，避免了业务线程因「网络数据处于准备中」导致的长时间等待问题，节省线程资源，这就是大名鼎鼎的事件驱动模型。
IO 读写线程、业务线程工作时，必有数据可操作执行，不会在 IO 等待上浪费资源，这便是事件驱动的核心思想。

Reactor 是事件驱动模型的一种实现。
Reactor 模式由 Reactor 线程、Handlers 处理器两大角色组成。


参考文献：
I/O多路复用模型之 select、poll、epoll_select poll epoll网络io模型-CSDN博客
一文搞懂，4种主要的 I/O 模型（高并发IO的底层原理）_高并发io和大量io的区别-CSDN博客

